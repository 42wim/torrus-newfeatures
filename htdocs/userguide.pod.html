<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Torrus User Guide</title>
<link rel="stylesheet" href="torrusdoc.css" type="text/css" />
<link rev="made" href="mailto:gerrit@familiehaase.de" />
</head>

<body>

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#torrus_user_guide">Torrus User Guide</a></li>
	<ul>

		<li><a href="#quick_start_guide">Quick start guide</a></li>
		<li><a href="#configuration_guidelines">Configuration guidelines</a></li>
		<li><a href="#handling_snmp_errors">Handling SNMP errors</a></li>
		<li><a href="#tips_and_tricks">Tips and tricks</a></li>
		<ul>

			<li><a href="#comments__descriptions__and_legends">Comments, descriptions, and legends</a></li>
			<li><a href="#grouping_the_datasources_alternatively">Grouping the datasources alternatively</a></li>
			<li><a href="#amending_autogenerated_xml_files_with_xupdate">Amending autogenerated XML files with XUpdate</a></li>
			<li><a href="#extracting_the_configuration_skeleton">Extracting the configuration skeleton</a></li>
			<li><a href="#automating_xml_generation">Automating XML generation</a></li>
			<li><a href="#several_torrus_instances_on_one_server">Several Torrus instances on one server</a></li>
			<li><a href="#changing_the_default_short_graph">Changing the default short graph</a></li>
			<li><a href="#watching_the_collector_failures">Watching the collector failures</a></li>
			<li><a href="#viewing_external_rrd_files">Viewing external RRD files</a></li>
		</ul>

		<li><a href="#torrus_usage_scenarios">Torrus usage scenarios</a></li>
		<ul>

			<li><a href="#scenario_1__netflow_traffic_analyser">Scenario 1. Netflow Traffic Analyser</a></li>
			<li><a href="#scenario_2__backbone_traffic_statistics">Scenario 2. Backbone Traffic Statistics</a></li>
		</ul>

		<li><a href="#troubleshooting_guidelines">Troubleshooting guidelines</a></li>
		<ul>

			<li><a href="#snmp_error__received_toobig_1_">SNMP Error: Received <code>tooBig(1)</code></a></li>
			<li><a href="#database_lock_troubleshooting">Database lock troubleshooting</a></li>
		</ul>

	</ul>

	<li><a href="#author">Author</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<h1><a name="torrus_user_guide">Torrus User Guide</a></h1>
<p>
</p>
<h2><a name="quick_start_guide">Quick start guide</a></h2>
<p>The steps below will explain you how to make the thing running.</p>
<p><strong>Install Torrus</strong>. Follow the <em>Torrus Installation Instructions</em> document,
all prerequisits and necessary steps are described there.</p>
<p><strong>What is where</strong>. The executables reside in 
<em>/usr/local/torrus/bin/</em>. You normally don't need to access this
directory, because the commandline wrapper, <code>torrus</code>, is installed
in a usual execution path (<em>/usr/local/bin</em>).
All site-specific behaviour is controlled by
configuration files in <em>/usr/local/etc/torrus/conf/</em>.
Usually you need to change <em>torrus-siteconfig.pl</em> only. In this file, you
must list your XML configuration sources. The datasource trees configuration
is read out of XML files. They are searched in several directories,
normally <em>/usr/local/torrus/xmlconfig/</em> and <em>/usr/local/etc/torrus/xmlconfig/</em>. The first one contains
files that come with Torrus distribution, and the second one is for your local
site-specific XML files. Global site-specific XML configuration parameters
may be defined in <em>site-global.xml</em>.
XML configuration is compiled into internal database representation
by <code>torrus compilexml</code> command. The database itself is resided in
<em>/var/torrus/db/</em>, and must be writable by your Apache server
(normally the installer takes care of it). It is safe to re-compile the
configuration while the Torrus daemons are running.</p>
<p><strong>The datasource trees</strong>. Torrus configuration consists of a number of <em>trees</em>.
Each tree is independent from the others. A tree may run one Collector and
one Monitor process. Also the web interface access control lists
differentiate the user rights by datasource trees.</p>
<p><strong>Inside the tree</strong>. A tree defines the hierarchy of Torrus datasources.
The structure of the tree is solely defined by XML configuration files.
The tree consists of <em>nodes</em>, each being either a <em>subtree</em> or a <em>leaf</em>.
Subtrees contain child subtrees and/or leaves. The leaf represents a
datasource: normally this is a numerical value that changes over time.
The leaf is the entity that may be presented as a graph.
There are leaves of special type: <em>multigraph</em>.
They are not numerical values, and are designed for
drawing several values in one graph. Each node has <em>path</em>, a
string that consists of slashes and node names, and uniquely identifies this
node. The path of a subtree always ends with slash, and the root of the tree
has the path consisting of a single slash.</p>
<p><strong>Trees configuration</strong>. The trees are defined in <em>torrus-siteconfig.pl</em>.
See <em>Torrus Installation Instructions</em> for a basic example of tree
configuration.</p>
<p><strong>Round-robin databases</strong>. Currently only one type of data storage is
supported: Round-robin database (RRD) files. See <em>RRDtool</em> manuals
for more details. Each leaf represents a datasource stored in an
RRD file. Of course, several leaves may refer to different datasources within
the same RRD file. Even more, more than one leaf may refer to the same
datasource within an RRD file. RRD files are created and updated either by
<code>collector</code>, or by some other external programs.</p>
<p><strong>Define the targets</strong>. If you only want to collect SNMP counters
from some network devices' interfaces, there's a couple of tools
called <code>torrus genddx</code> and <code>torrus devdisover</code>.
The first one creates a basic discovery instructions file, and the second
one uses the discovery instructions to explore the SNMP device capabilities
and information: interface names, input/output counters,
CPU and memory usage, temperature sensors (for Cisco devices), and many
other vendor-specific statistics sources.</p>
<p>Torrus is much more than just an SNMP collector. So, when you decide
to use it in a more advanced way, you will have to read the whole bit of
this guide, and also <em>Torrus XML Configuration Guide</em> and probably some
other documents too.</p>
<p><strong>Build the hierarchy</strong>. By default, <code>torrus genddx</code> will put all your
devices into one hierarchy: <code>/Routers/&lt;hostname&gt;/...</code>.
The subtree name, <code>Routers</code>, may be changed with a command line option
of <code>torrus genddx</code>. This program may also read the device names
(or IP addresses in case if you don't use DNS) from space-delimited text files.</p>
<pre>
  torrus genddx \
    --hostfile=myrouters.txt \
    --domain=example.net \
    --community=MySecretSNMPCommunity \
    --out=myrouters.ddx \
    --discout=myrouters.xml \
    --subtree=/My_Routers \
    --datadir=/data1/torrus/collector_rrd</pre>
<pre>
  torrus genddx \
    --hostfile=myswitches.txt \
    --domain=example.net \
    --community=MySecretSNMPCommunity \
    --out=myswitches.ddx \
    --discout=myswitches.xml \
    --subtree=/My_Switches \
    --datadir=/data1/torrus/collector_rrd</pre>
<pre>
  torrus devdiscover  --in=myrouters.ddx</pre>
<pre>
  torrus devdiscover  --in=myswitches.ddx</pre>
<p>In the example above, the routers' and switches' names are read from
<em>myrouters.txt</em> and <em>myswitches.txt</em> in the user's current directory.
They form a hierarchy with two subtrees: <code>/My_Routers/</code> and <code>/My_Switches/</code>.
<code>genddx</code> creates the discovery instruction XML files into
<em>myrouters.ddx</em> and <em>myswitches.ddx</em> accordingly. By default,
you would find them in <em>/usr/local/etc/torrus/discovery/</em>.
The result of <code>devdiscover</code> is the Torrus configuration files:
<em>myrouters.xml</em> and <em>myswitches.xml</em>, placed into
<em>/usr/local/etc/torrus/xmlconfig/</em>. The <code>collector</code> will place the
RRD files into <em>/data1/torrus/collector_rrd</em>. Make sure that this directory
exists, has enough free space, and is writable by <code>torrus</code> user.</p>
<p><strong>Note:</strong> the <code>genddx</code> utility is designed as a one-time helper, so
that you create your basic discovery instructions files from scratch.
Further on, the discovery files should be maintained separately.</p>
<p>Another useful utility is called <code>ttproclist</code>. It can be used to generate 
a DDX file from a template and a list of SNMP hosts. It is very useful if
you want to monitor many devices of similar type or function.</p>
<p>You can also define a <em>bundle</em> file in your DDX file. <code>Genddx</code> will
create it after all devices would discovered, and it will contain 
&lt;include&gt; statements for all XML files. This makes it practical to
use one XML file per SNMP host, and use the bundle file for inclusion
in the tree configuration.</p>
<p><strong>Add your XML files to the tree configuration</strong>. For each tree,
<em>/usr/local/etc/torrus/conf/torrus-siteconfig.pl</em> lists the XML files that have to be
compiled for it. In the example above, you would add <em>myrouters.xml</em> and
<em>myswitches.xml</em> into <code>xmlfiles</code> array in the tree configuration.</p>
<p>See <em>Torrus SNMP Discovery User Guide</em> for more details on how
<code>genddx</code> and <code>devdisover</code> interact and how you can customize
the discovery process.</p>
<p><strong>Tip</strong>: in most cases, your hierarchy division will be different.
It might be arranged by geographical locations, or by customer names.
There is a configuration statement that allows you to include other
XML files into configuration, thus giving you a big flexibility
in building the data hierarchies.</p>
<p><strong>Compile the configuration</strong>. Now that your configuration is
ready, you need to execute the compiler:</p>
<pre>
  torrus compile --tree=treename --verbose
  
For most of the processes that you run within Torrus, you need to specify
the tree name with C&lt;--tree&gt; option. Some proramms accept C&lt;--all&gt; option,
which causes them to process all existing trees.
With C&lt;--verbose&gt; option, the compiler tells you about the files being
processed, and about some other actions that may take quite a long time.
It will also tell you if there's any error in your configuration.</pre>
<p><strong>Build the search database</strong>. The search database is updated by executing
the following command:</p>
<pre>
  torrus bs --global --verbose</pre>
<p>For users that are allowed to display all the trees, you can enable the
global search across all trees:</p>
<pre>
  torrus acledit --addgroup=staff --permit=GlobalSearch --for='*'</pre>
<p><strong>Launch the collector</strong>. Assuming that compilation went smoothly,
you may now launch the data collector:</p>
<pre>
  torrus collector --tree=treename</pre>
<p>Without additional options, the collector will fork as a daemon
process, and write only error messages in its log file,
<em>/var/log/torrus/collector.treename.log</em>.</p>
<p>There is a file that is created by <code>./configure</code>, called <em>init.d/torrus</em>.
You may place it into a directory where your system looks for startup scripts
(<em>/etc/init.d/</em> on Solaris and some Linuxes, <em>/usr/local/etc/rc.d/</em>
on FreeBSD). Probably you need to rename and edit the script before using.
Note that it also executes another daemon, <code>monitor</code>.</p>
<p>The <code>monitor</code> daemon is used for monitoring the thresholds in the
data files. For more details, see the <em>Torrus XML configuration guide</em>,
in the section about monitor definitions.</p>
<p><strong>Define the ACLs</strong>. By default, user authentication is enabled in the web
interface. You can change this by setting
<code>$Torrus::ApacheHandler::authorizeUsers = 0</code> in your <em>torrus-siteconfig.pl</em>.
In order to get use of user authentication, you need to create <em>groups</em>
and <em>user</em> accounts. Each user belongs to one or more groups, and each group
has access to a set of datasource trees. See
<em>Torrus Installation Instructions</em> for a basic example.</p>
<p><strong>Browse with your browser</strong>. Provided that you followed the
installation guide to the end, and your HTTP server is running,
your Torrus hierarchy must be visible  with your favorite web browser.</p>
<p>
</p>
<h2><a name="configuration_guidelines">Configuration guidelines</a></h2>
<p>In complete detail, the XML configuration is described in
<em>Torrus XML Configuration Guide</em>. The guidelines below will help
you to read that document.</p>
<p><strong>Tree structure</strong>. The tree structure is defined by the structure of
<code>&lt;subtree&gt;</code> and <code>&lt;leaf&gt;</code> XML elements. The rule is simple:
child XML elements of a <code>&lt;subtree&gt;</code> element define the child
nodes in the configuration tree.</p>
<p><strong>Parameters</strong>. Each node has a number of parameters. They are defined
by <code>&lt;param&gt;</code> XML element. Parameters are inherited:
the child node has all its parent's parameters, some of which may be
overridden.</p>
<p><strong>Additive configuration</strong>. The whole XML configuration is additive.
It means that you may define your subtree several times across
your XML configuration, and the new parameters and child nodes will
be added to previously defined ones.</p>
<p><strong>Templates</strong>. Some pieces of configuration may be written as templates,
and then re-used in multiple places.</p>
<p>The <code>configsnapshot</code> utility generates one large XML file back from
the compiled configuration. Its main purpose is backup of the configuration,
but it can also be used for studying the relationships between templates
and input files.</p>
<p>
</p>
<h2><a name="handling_snmp_errors">Handling SNMP errors</a></h2>
<p>During SNMP discovery process, some SNMP devices may not be reachable.
By default, <code>devdiscover</code> reports the error, and does not write the output
XML file containing that device. It also skips writing the bundle files that
contain the output file affected.</p>
<p>When <code>devdiscover</code> is executed with <code>--forcebundle</code> option, the bundle
files are written, and the output files related to the unreachable
devices are skipped from the bundles. This ensures that we always get
a configuration that may compile and run the collector.</p>
<p>Another option, <code>--fallback=DAYS</code>, if given together with <code>--forcebundle</code>,
tells the discovery engine to reuse old XML files if the related SNMP devices
are not reachable and the files are not older than DAYS.</p>
<p>If an SNMP device is unreachable by the moment of the collector initialization,
the collector reports the error and waits for a period of time specified in
<code>$Torrus::Collector::SNMP::unreachableRetryDelay</code>, which is 10 minutes by
default. It then tries to reach the device with the specified retry interval
during some period of time, defined in
<code>$Torrus::Collector::SNMP::unreachableTimeout</code>, by default 6 hours.
If the device is not available within the specified timeout, it is excluded
from collection. It would be tried again on collector initialization
only (at the collector process start or after recompiling the configuration).</p>
<p>If a device is not reachable during the normal collector running cycle,
it is retried in every collector's cycle (usually every 5 minutes),
during the period defined in <code>$Torrus::Collector::SNMP::unreachableTimeout</code>.
It will be then excluded from configuration after the timeout.</p>
<p>If a device hardware configuration changes after the <code>devdiscover</code>
execution, the collector may not find some values in SNMP tables,
such as interface names in ifTable. It then excludes such datasources from
collection immediately.</p>
<p>
</p>
<h2><a name="tips_and_tricks">Tips and tricks</a></h2>
<p>
</p>
<h3><a name="comments__descriptions__and_legends">Comments, descriptions, and legends</a></h3>
<p><code>torrus devdiscover</code> will extract some useful information from
your SNMP devices, and place it in the XML configuration:</p>
<ul>
<li><strong><a name="item_interface_descriptions">Interface descriptions</a></strong><br />
</li>
The value of the SNMP variable <code>ifAlias</code> (<code>1.3.6.1.2.1.31.1.1.1.18</code>)
will be used as interface comment. In Cisco IOS, this is controlled by
<code>description</code> interface configuration command.
<p></p>
<li><strong><a name="item_location_and_contact">Location and contact</a></strong><br />
</li>
Two other SNMP values: <code>sysLocation</code> (<code>1.3.6.1.2.1.1.6.0</code>) and
<code>sysContact</code> (<code>1.3.6.1.2.1.1.4.0</code>) will be used in the legend text
for each device. In Cisco IOS, their values are controlled by
<code>snmp-server location</code> and <code>snmp-server contact</code> global configuration
commands.
<p></p></ul>
<p>
</p>
<h3><a name="grouping_the_datasources_alternatively">Grouping the datasources alternatively</a></h3>
<p>In most cases, you would want to have several different groupings of
your datasources.</p>
<p>For instance, the default <code>devdiscover</code> gives only one level of freedom:
the subtree name above the host level. It's reasonable to use this name for
grouping by geographical location . Thus, the hierarchy
would be characterised as
<code>/[location]/[hostname]/[interface]/[counter]</code>.</p>
<p>Let's say you would like to have alternative grouping, such as:</p>
<ul>
<li><strong><a name="item_by_customer_connection_3a">by customer connection:</a></strong><br />
</li>
Each customer is identified by name, and you'd like to see statistics
for all interfaces connected to a given customer;
<p></p>
<li><strong><a name="item_by_service_3a">by service:</a></strong><br />
</li>
Your network is designed to provide various services, and you'd like to
group your devices or interfaces by service;
<p></p>
<li><strong><a name="item_by_customer_and_location_3a">by customer and location:</a></strong><br />
</li>
For each customer, group the connection by geographical location.
<p></p></ul>
<p>Torrus provides three different ways for organising your datasources:</p>
<ul>
<li><strong><a name="item_aliases_2e">Aliases.</a></strong><br />
</li>
With <code>&lt;alias&gt;</code> statement, you can add symbolic names to your
nodes. If the new alias is defined as a reference to non-existing subtree,
the new subtrees are created. Alias is only a symbolic link: when you click
to the alias name in your browser, Torrus redirects it to the real datasource
in its normal subtree. See the example in <em>Torrus XML Configuration Guide</em>.
<p></p>
<li><strong><a name="item_ds_2dtype_3drrd_2dfile">ds-type=rrd-file</a></strong><br />
</li>
You can create a leaf in some arbitrary place of your hierarchy that
points to an existing RRD file. This RRD file may be updated by
other datasource in your hierarchy. The advantage of such approach is
that this leaf may have its own <em>legend</em> and <em>comment</em> parameters,
alternative view parameters, etc.
<pre>
    &lt;leaf name=&quot;FoobarIn&quot;&gt;
      &lt;param name=&quot;ds-type&quot;           value=&quot;rrd-file&quot; /&gt;
      &lt;param name=&quot;leaf-type&quot;         value=&quot;rrd-def&quot; /&gt;
      &lt;param name=&quot;data-file&quot;         value=&quot;rtr01_Fa0_1.rrd&quot; /&gt;
      &lt;param name=&quot;rrd-cf&quot;            value=&quot;AVERAGE&quot; /&gt;
      &lt;param name=&quot;rrd-ds&quot;            value=&quot;locIfInBitsSec&quot; /&gt;
      &lt;param name=&quot;comment&quot;
             value=&quot;Foobar input traffic&quot;/&gt;
      &lt;param name=&quot;graph-legend&quot;      value=&quot;Bits in&quot; /&gt;
      &lt;param name=&quot;legend&quot;&gt;
         Switch name: rtr01; Interface: Fa0/1;
      &lt;/param&gt;
    &lt;/leaf&gt;</pre>
<p>In the example above, this leaf is defined somewhere in the hierarchy.
It refers to the RRD file updated by Torrus SNMP collector.
For more examples, see the template <em>read-cisco-interface-counters</em>
in <em>vendor/cisco.ios.xml</em>.</p>
<p></p>
<li><strong><a name="item_tokensets">Tokensets</a></strong><br />
</li>
Tokenset is an arbitrary collection of datasource leaves. It is characterised
by its name and description. There are two ways to add a leaf to a tokenset:
by the parameter <em>tokenset-member</em>, or by defining a monitor action.
A tokenset is normally displayed in compact form: by default, 6-hour graphs
are put by two in a row.
<p></p></ul>
<p>
</p>
<h3><a name="amending_autogenerated_xml_files_with_xupdate">Amending autogenerated XML files with XUpdate</a></h3>
<p>Sometimes there is a need to modify the configuration generated by
<code>devdiscover</code>. Modifying the generated XML files by hand would not be
a good option: it would need some manual work every time you update
your hardware setup. A better approach would be to have the tools
that would automate such configuration update.</p>
<p>One of the possibilities for such automation would be XSLT
&lt;<a href="http://www.w3.org/TR/xslt">http://www.w3.org/TR/xslt</a>&gt;. But it's rather
complicated task to use XSLT for slight changes in XML files.</p>
<p>A good approach has been made by XUpdate Working Group
&lt;<a href="http://www.xmldb.org/xupdate/">http://www.xmldb.org/xupdate/</a>&gt;. Their Working Draft document
describes a language for XML editing commands. It allows to perform
small updates to an existing XML document, like insertion of elements,
updating of existing elements, or deleting. The only drawback is
that the specification hasn't been updated since September 2000,
and it contains some unclear statements, which make it difficult to
implement compatible applications. In addition, there has been
not enough efforts to adopt XUpdate as a W3C standard.
However, this is the only kind-of-a-standard language for such tasks as
XML editing commands.</p>
<p>Thanks to Petr Pajas, there is an XUpdate implementaytion in Perl.
<code>XML::XUpdate::LibXML</code> module is available at CPAN, and it installs
a small commandline utility, <code>xupdate</code>. In addition, Petr has created
a set of utilities integrated into a single shell wrapper:
&lt;<a href="http://xsh.sourceforge.net">http://xsh.sourceforge.net</a>&gt;. It is very useful for many different
things, such as XPath expressions testing, and many others.</p>
<p>A typical XUpdate instructions file would looke like follows:</p>
<pre>
 &lt;?xml version=&quot;1.0&quot;?&gt;
 &lt;xupdate:modifications version=&quot;1.0&quot;
                        xmlns:xupdate=&quot;<a href="http://www.xmldb.org/xupdate">http://www.xmldb.org/xupdate</a>&quot;&gt;</pre>
<pre>
 &lt;!-- Insert additional creator-info after the last one --&gt;
 &lt;xupdate:insert-after
   select=&quot;/configuration/creator-info[not(following-sibling::creator-info)]&quot;&gt;
   &lt;creator-info&gt;
     This file was modified with XUpdate script setmonitor.xupdate.xml
   &lt;/creator-info&gt;
 &lt;/xupdate:insert-after&gt;</pre>
<pre>
 &lt;!-- For every ifError leaf, set the monitor --&gt;
 &lt;xupdate:append select=&quot;//subtree[apply-template[@name='iftable-errors']]&quot;&gt;
   &lt;xupdate:element name=&quot;subtree&quot;&gt;
    &lt;xupdate:attribute name=&quot;name&quot;&gt;ifErrors&lt;/xupdate:attribute&gt;
     &lt;param name=&quot;monitor&quot; value=&quot;check-iferrors&quot;/&gt;
   &lt;/xupdate:element&gt;
 &lt;/xupdate:append&gt;</pre>
<pre>
 &lt;/xupdate:modifications&gt;</pre>
<p>This example is part of Torrus distribution, and the file is named
<em>examples/setmonitor.xupdate.xml</em>. Your commands to apply these XUpdate
instructions would be like</p>
<pre>
  torrus devdiscover --in=routers.ddx --out=routers.xml</pre>
<pre>
  cd /usr/local/etc/torrus/xmlconfig
  xupdate -j /usr/local/torrus/examples/setmonitor.xupdate.xml \
    routers.xml &gt; routers1.xml</pre>
<p>More XUpdate examples will be included in the future.</p>
<p>
</p>
<h3><a name="extracting_the_configuration_skeleton">Extracting the configuration skeleton</a></h3>
<p>Another aproach to amending the autogenerated confguration is as follows.</p>
<p>Torrus distribution has a special-purpose XSLT template,
<em>extract-skeleton.xsl</em>, designed to strip all parameters and template
applications from a given XML configuration, and leave the tree structure
only. Given that <em>routers.xml</em> is some autogenerated configuration,
you may run</p>
<pre>
  xsltproc /usr/local/torrus/scripts/xml/extract-skeleton.xsl routers.xml  | \
    xmllint --format --output routers-skeleton.xml -</pre>
<p>You can add your changes to the new file, <em>routers-skeleton.xml</em>, and add
it to your Torrus configuration. These changes may be performed manually
or by means of XUpdate technique described above.</p>
<p>
</p>
<h3><a name="automating_xml_generation">Automating XML generation</a></h3>
<p>It is quite common task that you want Torrus to monitor certain set of
devices, and <code>devdiscover</code> does not (yet) support them. Of course,
it's quite a pain to maintain a manually written XML file, especially if
the there are more than one devices of the same type.</p>
<p>In such case you may benefit from the approach suggested by
Christian Schnidrig:</p>
<p>Imagine you have 50 <em>gizmos</em> which are able to speak SNMP and which you would
like to put into some Torrus tree structure. A good designer's approach would
be to keep the data and the presentation separately. In addition, changing
the presentation once would produce 50 changes accordingly.
To do that, let's create two files: <em>gizmos.data</em> and <em>gizmos.tmpl</em>.
The first one would contain data about our devices:</p>
<pre>
    [%
      gizmos = [
        {
          name =&gt; 'atwork'
          color =&gt; 'blue',
          location =&gt; 'Javastrasse 2, 8604 Hegnau'
          description =&gt; 'My gizmo @ Sun'
          community =&gt; 'blabla',
          hands =&gt; [
              {name =&gt; 'Left'}
              {name =&gt; 'Right'}
            ],
        }
        {
          name =&gt; 'athome'
          color =&gt; 'gray',
          location =&gt; 'Riedstrasse 120, 8604 Hegnau'
          description =&gt; 'My gizmo @ Home'
          community =&gt; 'blabla',
          hands =&gt; [
              {name =&gt; 'Upper'}
              {name =&gt; 'Lower'}
            ],
        }
      ]</pre>
<pre>
    %]</pre>
<p>Then <em>gizmos.tmpl</em> would contain the XML template that would produce
the Torrus configuration file:</p>
<pre>
    [% PROCESS $data %]
    &lt;?xml version=&quot;1.0&quot;?&gt;
    &lt;configuration&gt;
      &lt;datasources&gt;
        &lt;subtree name=&quot;SNMP&quot;&gt;
          &lt;subtree name=&quot;Gizmos&quot;&gt;
          [% FOREACH g = gizmos %]
          &lt;!-- ******************************************************* --&gt;
          &lt;!-- [% g.name %] --&gt;
          &lt;subtree name=&quot;[% g.color %]&quot;&gt;
              &lt;alias&gt;/ByName/[% g.name %]/&lt;/alias&gt;</pre>
<pre>
              &lt;param name=&quot;snmp-community&quot;  value=&quot;[% g.community %]&quot; /&gt;
              &lt;param name=&quot;comment&quot;         value=&quot;[% g.description %]&quot; /&gt;
              &lt;param name=&quot;snmp-host&quot;       value=&quot;[% g.name %]&quot; /&gt;
              &lt;param name=&quot;legend&quot;&gt;
                Description: [% g.description %]
                Location:    [% g.location %]
              &lt;/param&gt;</pre>
<pre>
              [% FOREACH h=$g.hands %]
              &lt;leaf name=&quot;[% h.name %]Hand&quot;&gt;
                &lt;!-- do something, my fantasy exhausted here --&gt;
              &lt;/leaf&gt;
          &lt;/subtree&gt;
          [% END %]
        &lt;/subtree&gt;
      &lt;/subtree&gt;
    &lt;/datasources&gt;
    &lt;/configuration&gt;</pre>
<p>See <em>xmlconfig/examples/servers.data</em> and <em>xmlconfig/examples/servers.tmpl</em>
for a more useful example of the described approach.</p>
<p>At the end, you will generate the Torrus config with the <code>tpage</code> utility,
which is the standard part of Template-Toolkit package:</p>
<pre>
  tpage --define data=gizmos.data gizmos.tmpl &gt; gizmos.xml</pre>
<p>
</p>
<h3><a name="several_torrus_instances_on_one_server">Several Torrus instances on one server</a></h3>
<p>Sometimes it is necessary to have a separate instance of Torrus for testing
purposes on the same server as the production installation.
In the example below, a completely autonomous installation of Torrus is
installed in <em>/usr/testtorrus</em> directory on a FreeBSD system.</p>
<ul>
<li><strong><a name="item_directory_structure">Directory structure</a></strong><br />
</li>
All files are located in subdirectories of <em>/usr/testtorrus</em>. No other
directories are affected. This ensures that deinstallation would be easy
and safe.
<p>Four subdirectories are created:</p>
<ul>
<li><strong><a name="item__2fusr_2ftesttorrus_2fapache"><em>/usr/testtorrus/apache</em></a></strong><br />
</li>
This directory contains Apache HTTP daemon configuration and logs. Create 3
subdirectories here: <em>etc</em>, <em>htdocs</em>, and <em>var</em>.
<p></p>
<li><strong><a name="item__2fusr_2ftesttorrus_2fhome"><em>/usr/testtorrus/home</em></a></strong><br />
</li>
This is the installation directory of Torrus.
<p></p>
<li><strong><a name="item__2fusr_2ftesttorrus_2fetc"><em>/usr/testtorrus/etc</em></a></strong><br />
</li>
Directory for configuration files.
<p></p>
<li><strong><a name="item__2fusr_2ftesttorrus_2fvar"><em>/usr/testtorrus/var</em></a></strong><br />
</li>
Directory for logs, database and PID files.
<p></p>
<li><strong><a name="item__2fusr_2ftesttorrus_2fcollector_rrd"><em>/usr/testtorrus/collector_rrd</em></a></strong><br />
</li>
Collector will store RRD files here.
<p></p>
<li><strong><a name="item__2fusr_2ftesttorrus_2fsrc"><em>/usr/testtorrus/src</em></a></strong><br />
</li>
Distribution files will be stored and unpacked here.
<p></p></ul>
<li><strong><a name="item_installation_procedure">Installation procedure</a></strong><br />
</li>
<pre>
  cd /usr/testtorrus/src
  gzip -dc torrus-1.0.0.tar.gz | tar xvf -
  cd torrus-1.0.0
  ./configure pkghome=/usr/testtorrus/home \
    sitedir=/usr/testtorrus/etc \
    logdir=/usr/testtorrus/var/log \
    piddir=/usr/testtorrus/var/run \
    varprefix=/usr/testtorrus/var \
    wrapperdir=/usr/testtorrus
  make install</pre>
<li><strong><a name="item_devdiscover_configuration">Devdiscover configuration</a></strong><br />
</li>
Use devdiscover as usual. Place your discovery instruction files in
<em>/usr/testtorrus/etc/discovery/</em>, and make sure that
<code>data-dir</code> is set to <em>/usr/testtorrus/collector_rrd</em>.
<p></p>
<li><strong><a name="item_apache_configuration">Apache configuration</a></strong><br />
</li>
We reuse the same binaries and libraries as the main installation of Apache,
but the daemon is launched with our special configuration.
We assume that Apache is pre-configured for mod_perl. SSL support is not
included in this example, but it's quite straightforward to implement
if you need it.
<p>Create a copy of <em>httpd.conf</em> and place it in <em>/usr/testtorrus/apache/etc</em>.
With a text editor, replace the configutration options with the values
given below:</p>
<pre>
  # Leave server root as it was in the original config. Apache uses
  # it for modules loading
  ServerRoot &quot;/usr/local&quot;</pre>
<pre>
  # make sure that everything that apache writes
  # goes into our directories
  PidFile /usr/testtorrus/apache/var/httpd.pid
  ScoreBoardFile /usr/testtorrus/apache/var/httpd.scoreboard</pre>
<pre>
  # Optional: limit the memory and CPU impact
  MinSpareServers 2
  MaxSpareServers 5
  StartServers 3
  MaxClients 10</pre>
<pre>
  # We open our HTTP service on TCP port 8123. Choose other
  # port if this one is occupied
  Port 8123</pre>
<pre>
  # Not really necessary, but you might want to use it someday
  DocumentRoot &quot;/usr/testtorrus/apache/htdocs&quot;</pre>
<pre>
  # Find the Directory options for the old htdocs, and
  # replace the path if you changed DocumentRoot above
  &lt;Directory &quot;/usr/testtorrus/apache/htdocs&quot;&gt;
  ... some default stuff here ...
  &lt;/Directory&gt;</pre>
<pre>
  # Make sure the logs are written where we expect them to.
  ErrorLog /usr/testtorrus/apache/var/httpd-error.log
  CustomLog /usr/testtorrus/apache/var/httpd-access.log combined</pre>
<pre>
  # TCP port number as above
  NameVirtualHost *:8123</pre>
<pre>
  # Quite standard virtual server configuration. Replace fake
  # domain names with your real ones.
  &lt;VirtualHost *:8123&gt;
    ServerAdmin root@myserver.com
    DocumentRoot /usr/testtorrus/home/web
    ServerName torrus.myserver.com
    CustomLog /usr/testtorrus/apache/var/torrus.myserver.com.log &quot;combined&quot;
    PerlModule Apache::PerlRun
    PerlRequire &quot;/usr/testtorrus/home/conf_defaults/webmux.pl&quot;
    Alias /plain/ &quot;/usr/testtorrus/home/sup/webplain&quot;
    &lt;Location /&gt;
      SetHandler perl-script
      PerlHandler Torrus::ApacheHandler
    &lt;/Location&gt;
    &lt;Location /plain/&gt;
      SetHandler default-handler
      Options None
    &lt;/Location&gt;
  &lt;/VirtualHost&gt;</pre>
<p></p>
<li><strong><a name="item_apache_startup_script">Apache startup script</a></strong><br />
</li>
Save the following script as <em>/usr/testtorrus/apache/testtorrus.sh</em>:
<pre>
  #!/bin/sh
  case &quot;$1&quot; in
  start)
    /usr/local/sbin/httpd -f /usr/testtorrus/apache/etc/httpd.conf &amp;&amp; \
    echo 'apache started'
    ;;
  stop)
    [ -r  /usr/testtorrus/apache/var/httpd.pid  ] &amp;&amp; \
    kill `cat /usr/testtorrus/apache/var/httpd.pid` &amp;&amp; \
    echo 'apache stopped'
    ;;
  *)
    echo &quot;Usage: `basename $0` {start|stop}&quot; &gt;&amp;2
    ;;
  esac
  exit 0</pre>
<p></p></ul>
<p>
</p>
<h3><a name="changing_the_default_short_graph">Changing the default short graph</a></h3>
<p>The default small graph in overviews and tokenset listings shows last 6 hours
of data. It might be more convenient for you to graph last 24 hours,
or even longer. To do so, you only need to change one parameter,
<code>rrgraph-views</code>. You may change it on the top of the datasource tree, or
even only for some parts of the tree.</p>
<p>In <em>defaults.xml</em>, there's a view defiition called <code>last24h-small</code>. It is
exactly the same size as the 6-hours' <code>short</code> view, but it shows 24-hour
graph. Somewhere in Torrus configuration, you may have:</p>
<pre>
  &lt;datasources&gt;
    &lt;param name=&quot;rrgraph-views&quot;&gt;
      last24h-small,last24h,lastweek,lastmonth,lastyear
    &lt;/param&gt;
  &lt;/datasources&gt;</pre>
<p>The best place for this would be <em>site-global.xml</em>.</p>
<p>
</p>
<h3><a name="watching_the_collector_failures">Watching the collector failures</a></h3>
<p>There is a script in Torrus distribution in <em>examples/rrdup_notify.sh</em>,
which provides a simple way of telling if the collector runs right: it checks
the modification time of RRD files, and if any file is older than given
threshold, it sends an e-mail warning.</p>
<p>Copy the script file to some place in your system and edit it so that it fits
your requirements: you might want to change the maximum age
parameter (default is 1 hour), the notification e-mail address, and the
directory paths where to look for RRD files. Then <em>chmod</em> it so that it's
executable, and add it to <em>crontab</em>. Depending on your operation requirements,
it might run every hour, or few times a day, or even at business hours only.</p>
<p>The script writes the number of aged files in the e-mail subject, and lists
the file names in the body. In case of relatively large installation,
you might want to amend the script, in order to avoid too large email messages.</p>
<p>
</p>
<h3><a name="viewing_external_rrd_files">Viewing external RRD files</a></h3>
<p>Some external program may create its own RRD files, and you
may want to display and monitor them in Torrus.</p>
<p>Also some collector-generated RRDs may become outdated -- for example, after
a module is removed from a router, and the interface counters not
being updated any more.</p>
<p>The easiest way to use such files would be to utilize the
<code>torrus rrddir2xml</code> command. It generates the XML configuration file
that represents all RRD files found in a given directory. It can also
scan the directory recursively.</p>
<p>See also few examples in Torrus distribution. There are some
templates for use with Smokeping, OpenNMS, and Flowscan.</p>
<p>
</p>
<h2><a name="torrus_usage_scenarios">Torrus usage scenarios</a></h2>
<p>
</p>
<h3><a name="scenario_1__netflow_traffic_analyser">Scenario 1. Netflow Traffic Analyser</a></h3>
<p>Cisco routers are capable of exporting the traffic statistics
data in <em>Netflow</em> UDP packets.</p>
<p>A <em>cflowd</em> or <em>flow-tools</em> daemon collects Netflow packets into flow files.</p>
<p><em>FlowScan</em> software analyses the flow files and stores the
statistics into numerous RRD files.</p>
<p>Torrus is used to monitor the thresholds and diplay the graphs
in convenient form.</p>
<p>
</p>
<h3><a name="scenario_2__backbone_traffic_statistics">Scenario 2. Backbone Traffic Statistics</a></h3>
<p><em>CiscoWorks2000</em> or <em>NMSTOOLS</em> software is used to provide
the list of all devices in the network.</p>
<p>Torrus's <code>devdiscover</code> buids the XML configuration to monitor the
router interfaces, CPU and memory usage, and temperature sensors.</p>
<p>Data importing scripts generate configuration for alternative
grouping of the datasources: by location; by customer connection;
by device type; by service type; etc...</p>
<p>
</p>
<h2><a name="troubleshooting_guidelines">Troubleshooting guidelines</a></h2>
<p>
</p>
<h3><a name="snmp_error__received_toobig_1_">SNMP Error: Received <code>tooBig(1)</code></a></h3>
<p>For some devices, the collector may issue the following error messages:</p>
<pre>
 [27-May-2004 10:15:17*] SNMP Error for XX.XX.XX.XX:161:public: Received 
 tooBig(1) error-status at error-index 0</pre>
<p>For better performance, SNMP collector sends several SNMP requests in one
UDP datagram. The SNMP agent then tries to send the reply to all requests
in a single datagram, and this error indicates the failure. In most cases,
this is caused by the agent software limitations or bugs.</p>
<p>The number of requests per datagram is controlled by the parameter
<code>snmp-oids-per-pdu</code>, and it may be set in the discovery input XML or
in Torrus configuration XML. The default value is 40, and setting it to 10
generally works.</p>
<p>
</p>
<h3><a name="database_lock_troubleshooting">Database lock troubleshooting</a></h3>
<p>It may happen sometimes, that a process accessing Torrus database
terminates incorrectly, and the database becomes blocked.
A typical symptom of this is that the command
<code>torrus compilexml --all --verbose</code>
does not print anything and stays running forever, occupying zero
percent of CPU.</p>
<p>The nice, and the preferred way to solve the problem is
to use <code>db_recover</code> utility from BerkeleyDB package.
The brutal way is just to remove the databases and re-compile
all the configuration. <em>Note:</em> The ACL database is not automatically
backed up, and you need to take care of its backup before deleting
the contents of the database.</p>
<pre>
  ## The nice way uses BerkeleyDB db_recover
  ## (might be located in /usr/local/BerkeleyDB.4.1/bin/)
  /etc/init.d/apache stop
  /etc/init.d/torrus stop
  db_recover -h /var/torrus/db
  torrus compilexml --verbose --all
  /etc/init.d/torrus start
  /etc/init.d/apache start</pre>
<pre>
  ## The brutal way
  /etc/init.d/apache stop
  /etc/init.d/torrus stop
  cd /var/torrus/db
  rm -r *
  torrus compilexml --verbose
  /etc/init.d/torrus start
  /etc/init.d/apache start</pre>
<p>
</p>
<hr />
<h1><a name="author">Author</a></h1>
<p>Copyright (c) 2002-2007 Stanislav Sinyagin &lt;<a href="mailto:ssinyagin@yahoo.com">ssinyagin@yahoo.com</a>&gt;</p>

</body>

</html>
